# 前置准备  
  
## 数据库设计的步骤

1. 需求分析	
   - 调查机构情况与熟悉业务活动，明确用户的需求，确定系统的边界，生成数据字典和用户需求规格说明书
2. 概念结构设计
   - 将需求分析得到的用户需求抽象为概念模型，绘制E-R图
3. 逻辑结构设计
   - 将E-R图转换为与DBMS相符合的逻辑结构（包括数据库模式和外模式），例如E-R图向关系模型转换，再根据规范化理论对数据模型进行优化，设计用户子模式
4. 物理结构设计
   - 通常关系数据库物理设计的内容包括关系模式选择存取方法、以及设计关系、索引等数据库文件的物理存储结构
5. 数据实施
   - 建立实际数据库结构、试运行、装入数据
6. 数据库运行和维护
   - 维护数据库的安全性、完整性控制以及胸的转储和恢复；性能的监督、分析和改进；增加新功能；发现错误和修改错误

# 1.基础

## 1.1属性与属性组

案例：
一个学生表包含以下属性：

- 学号学号（StudentID）
- 姓名（Name）
- 年龄（Age）
- 性别（Gender）
- 学院（College）
- 专业（Major）

### 1.1.1**属性：**

1. 属性是关系型数据库表中的列，用来描述表中的数据特征或特征
2. 每个属性都代表了一个特定的数据项，如学生的**姓名、学号、年龄**等
3. 属性是表中的最小数据单元，具有特定的数据类型和约束，用来定义数据的格式和取值范围

### 1.1.2**属性组：**

1. 属性组是一组相关的属性，一起描述了一个实体或者对象的多个特征
2. 属性组通常用于表示一个逻辑上相关的数据集合
3. 可以将多个属性组合在一起，形成一个数据项，用来描述实体的某个方面
4. 例如**姓名、年龄和性别**可以组成一个基本的**个人信息属性组**；**学院和专业**可以组成一个**院系信息属性组**

## 1.2依赖

**定义：**
一个数据对象的值（或集合）对于其他数据对象的值（或集合）的决定性影响。它描述了数据之间的关系和相互依赖性。

### 1.2.1函数依赖

函数依赖描述了在一个关系中，一个数据对象（属性/列）的值决定另一个数据对象的值

具体而言，如果对于关系R中的属性集合X和Y，对于**X的每个可能的值，都存在唯一确定的Y的值**，那么我们称Y对于X具有函数依赖。**通常用X -> Y表示函数依赖**

例如，在一个学生表中，学生ID决定了学生姓名，那么我们可以表示为"学生ID -> 学生姓名"

### 1.2.1多值依赖

多值依赖描述了在一个关系中，一个数据对象的值决定了其他多个数据对象的值

具体而言，如果对于关系R中的属性集合X、Y和Z，对于X的每个可能的值，都存在唯一确定的Y和Z的值，那么我们称Y和Z对于X具有多值依赖。**通常用X ->> YZ表示多值依赖**

例如，在一个订单表中，订单ID决定了产品名称和产品价格，那么我们可以表示为："订单ID ->> 产品名称, 产品价格"。

## 1.3范式

### 1.3.1第一范式（1NF）

**概念：**
第一范式要求每个表中的每个列都是原子的，即不可再分。它消除了重复的数据和列的多值依赖。在第一范式中，每个表中的每个列都包含一个单一的值。

**举例：**
假设我们有一个学生信息表，其中包含学生ID、学生姓名和多个电话号码。在第一范式中，我们将表拆分成两个表，一个是学生信息表，包含学生ID和学生姓名，另一个是电话表，包含学生ID和电话号码。

### 1.3.2第二范式（2NF）

**概念：**
第二范式建立在第一范式的基础上。它要求表中的每个非主键列完全依赖于主键，而不是依赖于主键的一部分。它消除了部分依赖。

**举例：**

假设我们有一个订单表，其中包含

- 订单ID
- 产品ID
- 产品名称
- 产品价格

在第二范式中，我们将表拆分成两个表

一个是订单表，包含

- 订单ID
- 产品ID

另一个是产品表，包含

- 产品ID
- 产品名称
- 产品价格

**这样，产品信息不再依赖于订单ID，而是直接依赖于产品ID。**

### 1.2.3第三范式（3NF）

**概念：**

第三范式建立在第二范式的基础上。它要求表中的每个非主键列都不传递依赖于主键。换句话说，所有非主键列只依赖于主键，而不依赖于其他非主键列。它消除了传递依赖。

**举例：**

假设我们有一个图书馆管理系统，其中包含

- 书籍表
- 书籍作者表
- 书籍分类表

在第三范式中，我们将表拆分成三个表：书籍表、作者表、分类表

书籍表，包含

- 书籍ID
- 书籍名称
- 分类ID

作者表，包含

- 作者ID
- 作者姓名

分类表，包含

- 分类ID
- 分类名称

这样，每个表都只包含相关的数据，没有冗余

### 1.2.4巴斯-科德范式

**概念：**
巴斯-科德范式是一种更高级的范式，它要求表中的每个非主键列都不传递依赖于主键，同时消除了主键之间的依赖关系。

**举例：**

假设我们有一个员工表，其中包含员工ID、部门ID和部门名称。在BCNF中，如果存在函数依赖关系，我们需要进一步拆分表。在这种情况下，我们将员工表拆分成两个表，一个是员工表，包含员工ID和部门ID，另一个是部门表，包含部门ID和部门名称。这样，每个表都符合BCNF，并且消除了主键之间的依赖关系。

# 2.关系理论

## 2.1函数依赖

### 2.1.1非平凡的函数依赖：

**概念：**
非平凡的函数依赖指的是一个属性集合对于另一个属性集合的取值存在实际的依赖关系，且这种依赖关系**不是显而易见的或显然的**。换句话说，存在一种非平凡的关联关系，可以**通过已知的属性集合推导出另一个属性集合的取值**。

**举例：**
假设有一个关系表包含属性集合A和B，其中A是唯一标识每个元组的主键，而B是A的函数依赖。这种情况下，B对于A的取值存在非平凡的函数依赖。例如：

| A    | B    |
| ---- | ---- |
| 1    | X    |
| 2    | Y    |
| 3    | X    |

```
在上述示例中，B的取值取决于A的取值，而且存在多个A值对应于不同的B值。
```

### 2.1.2平凡的函数依赖：

**概念：**
平凡的函数依赖指的是一个属性集合对于另一个属性集合的取值没有实际的依赖关系，或者说这种依赖关系是显而易见的或显然的。平凡的函数依赖是一种非有趣的、琐碎的依赖关系，因为它并未提供任何关于属性之间的实际依赖关系的信息

**举例：**
平凡的函数依赖是指一个属性集合对于另一个属性集合的取值存在显而易见的依赖关系。例如，考虑以下关系表：

| A    | B    |
| ---- | ---- |
| 1    | X    |
| 2    | Y    |
| 3    | Z    |

```
在这种情况下，B的取值对于A的取值存在平凡的函数依赖，因为每个A值都有一个唯一的B值。
```

### 2.1.3完全函数依赖：

**概念：**
完全函数依赖指的是**一个属性集合完全决定了另一个属性集合的取值**，即在给定一个属性集合的情况下，不能通过删除该属性集合中的任何一个属性来保持函数依赖。换句话说，**完全函数依赖是指没有冗余属性的函数依赖关系**。

**举例：**
假设有一个关系表包含属性集合A、B和C，其中A是主键，而B和C是A的函数依赖。如果在给定A的情况下，无法通过删除属性B或C来保持函数依赖，则存在完全函数依赖。例如：

| A    | B    | C    |
| ---- | ---- | ---- |
| 1    | X    | Y    |
| 2    | X    | Z    |
| 3    | Y    | Z    |

```
在上述示例中，B和C的取值完全依赖于A的取值，因此不存在冗余属性。
```

### 2.1.4部分函数依赖：

**概念：**
部分函数依赖指的是**一个属性集合中的一部分属性对于另一个属性集合的取值存在依赖关系**，而不是整个属性集合对另一个属性集合的取值产生依赖。换句话说，部分函数依赖是指在给定一个属性集合的情况下，仍然可以通过去除该属性集合中的某些属性来保持函数依赖。

**举例：**
假设有一个关系表包含属性集合A、B和C，其中A是主键，而B和C是A的函数依赖。如果在给定A的情况下，可以通过删除属性B或C来保持函数依赖，则存在部分函数依赖。例如：

| A    | B    | C    |
| ---- | ---- | ---- |
| 1    | X    | Y    |
| 2    | X    | Z    |
| 3    | Y    | Z    |

```
在上述示例中，B和C的取值部分地依赖于A的取值，因为当A为1时，B可以是X或Y，C可以是Y或Z。
```

## 2.2码

"码"是指一个属性或属性集合，它能够唯一地标识一个关系表中的每个元组

1. 候选码
   是一个属性组（或者属性），通过改属性组能推出所有的属性，并且该属性组的任意子集都不能再退出所有属性了，即再满足完全函数依赖的前提喜爱，还得是最小的属性组
2. 超码
   能退出所有属性的属性组的集合，根据概念可知，候选码是极小的超码集，是超码的子集
3. 主码
   当有多个候选码时，选择一个作为主码，简称码
4. 主属性
   包含在任何一个候选码中的属性
5. 非主属性
   不包含在任何一个候选码中的属性
6. 外码
   关系模式R中，若有一个属性或属性组X，它不是R的码，但是X是另一个关系模式S中的码，简称X是R的外码
7. 全码
   最极端情况下，整个属性组都是码，成为全码

**举例：**

以一个**采购**、销售和**客户管理应用**的数据库为例来解释和说明码的概念

有以下几个关系表

1. 采购订单表：
   - 订单编号：主码，用于唯一标识每个采购订单
   - 供应商
   - 订单日期
2. 销售订单表：
   - 订单编号：主码，用于唯一标识每个采购订单
   - 客户编号
   - 订单日期
3. 产品表：
   - 产品编号：主码，用于唯一标识每个产品
   - 产品名称
   - 单价
4. 客户表：
   - 客户编号：主码，用于唯一标识每个客户
   - 客户姓名
   - 联系方式

**以上案例中用的的不同类型的码**

1. **主码**
   - 采购订单表中，订单编号作为主码，用于唯一标识每个采购订单，同样的在销售订单表中，订单编号也作为主码，用于唯一标识每个销售订单
   - 主码确保了每个订单的唯一性
2. 外码
   - 在销售订单表中，客户编号是一个外码，它引用了客户表中的主码，建立了销售订单与客户表之间的关联关系
   - 外码确保了销售订单与客户之间的一致性和完整性
3. 候选码
   - 考虑到整个数据库，可以将**订单编号、产品编号、和客户编号**作为候选码，都能唯一标识各自的**实体**（**采购订单、产品、客户**）
   - 候选码满足唯一性和最小性的要求
4. 非主属性
   - 在采购订单表中，供应商是一个非主属性
   - 供应商并不用于唯一标识采购订单，但是提供了与供应商相关的信息

# 3.数据库概念设计